# Day 2: Corruption Checksum
## Part 1
### Translation
당신이 문을 걸어 통과하자, 반짝이는 인간 형체가 당신을 향해 소리친다. "거기 너! 너 지금 쉬고 있는 것 같은데. 여기 와서 이 스프레드시트의 잘못된 점을 고치는 것을 도와줘 - 만약 한 밀리초가 더 지난다면, 모래시계 커서를 띄워줘야 한다고!"  
  
이 스프레드시트는 무작의 숫자들의 행들로 이루어져 있다. 복원 과정을 올바르게 진행하기 위해, 당신이 스프레드시트의 *체크섬*을 계산해야 한다. 각 행마다, 최대값과 최소값의 차이값을 계산하라; 체크섬은 그 차이값들의 합이다.  
  
예를 들어, 다음과 같은 스프레드시트가 주어진다:  
  
```
5 1 9 5
7 5 3
2 4 6 8
```
   - 첫번째 행의 최대값과 최소값은 `9`와 `1`이고, 그들의 차이값은 `8`이다.
   - 두번째 행의 최대값과 최소값은 `7`와 `3`이고, 그들의 차이값은 `4`이다.
   - 세번째 행의 최대값과 최소값의 차이값은 `6`이다.
  
이 예제에서, 스프레드시트의 체크섬은 `8 + 4 + 6 = 18`이다.  
당신의 퍼즐 입력의 스프레드시트의 *체크섬은 무엇인가*?  

### Solution
- 입력 : 여러 개의 수열들
- 처리 : 각 수열의 최대값과 최소값의 차이값의 합을 계산한다.
- 출력 : 각 수열의 최대값과 최소값의 차이값의 합
- [source](./Day_1/solution.py)
## Part 2
### Translation
--- Part Two ---

"잘했어; 결국 우리가 제대로 하고 있는게 맞네. 네 노력이 가상해서 **별**을 하나 줄게." 하지만, 프로그램이 약간 걱정스러워 보였다. 프로그램이 걱정할 수 있었나?  
  
"우리가 본 것을 토대로 하면, 사용자가 원하는 것은 스프레드시트에서 나누어 떨어지는 값들의 정보인 것 같네. 하지만, 우리들 중 아무도 그런 계산에 익수하지 않네. 우리는 비트 연산에 익숙하거든."  
  
목표는 한 숫자가 다른 숫자에 의해 나누어 떨어지는 두 개의 숫자를 각 행마다 찾는 것이다. 즉, 나눗셈 연산의 결과는 숫자 하나다. 당신은 각 행마다 숫자들을 찾고, 나눈 뒤, 그 몫들을 모두 더한다.  

예를 들어, 다음과 같은 스프레드시트가 주어진다:  
  
```
5 9 2 8
9 4 7 3
3 8 6 5
```
   - 첫번째 행에서, 나누어 떨어지는 관계의 수는 `8`과 `2` 둘 뿐이다. 나눗셈의 결과 몫은 `4`이다.
   - 두번째 행에서, 나누어 떨어지는 관계의 수는 `9`와 `3`이다. 결과는 `3`이다.
   - 세번째 행에서, 그 결과는 `2`이다.
  
이 예제에서, 나눗셈 몫들의 합은 `4 + 3 + 2 = 9`가 될 것이다.  

### Solution
- 입력 : 여러 개의 수열들
- 처리 : 각 수열의 나누어 떨어지는 수들의 나눗셈 몫의 합을 계산한다.
- 출력 : 각 수열의 나누어 떨어지는 수들의 나눗셈 몫의 합
- [source](./Day_2/solution.py)